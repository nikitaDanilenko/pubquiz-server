# Readme

This program consitutes a REST backend for the quiz service.
It handles various commands corresponding to creating, updating, and locking quizzes.
There is no deletion option, for future comparability, 
but deletion can be usually handled manually by someone with access to the actual files.

## Features

1. Creating new quizzes creates empty point pages for the whole quiz, and the individual groups.
   It also handles the entry on the main front page, 
   where all quizzes listed in the quiz directory are presented for future reference.

1. Upon quiz creation, the server also creates two PDF files.

   1. The main file is the sheet for the actual answers provided by the groups.
      The document is optimised for two-sided printing, and empty pages are inserted,
      when the number of pages is not a multiple of four.
      Additionally, the answer sheets contain a QR code with a link to the individual point page
      of the team.
      There is also some room for a team name, which can be entered by the moderator.

   1. The secondary document is a file containing only the QR codes.
      This document is intended for cases where users may have missed the use of the
      quiz management application,
      or when there are good reasons for using only individual sheets,
      and not the ones generated by the application.

      In practice, this file is probably more useful in an ad-hoc scenario than anywhere else,
      but there have been cases, where having the QR codes ready would have been handy.

1. Updating quizzes with points per round creates three different graphs on the main page.

   1. The main bar chart denotes the overall points of all teams.

   1. The second bar chart denotes the points of the teams in the individual rounds.
      The cumulative chart for a given round is the stack of the individual charts of
      all rounds up to and including the given round.

   1. The third graph is a line group denoting the linear interpolation of the cumulative points.
      This chart can be used to view the progress over time, 
      but is less suited to observe the actual status.
      In theory, one could use this (and the other graphs) by entering points per question,
      rather than per round.
      This would make the interpolation precise, but came with two major down-sides:

      1. The amount of input would be rather large, and one could no longer distinguish
         between rounds and questions.
         However, one could change the word for "round" with the word for "question"
         and thus provide a consistent presentation.

      1. More importantly, this feature would let everyone know,
         which team knew which answer, and which one did not.
         This is likely undesired, despite the overall competitive character of the game.

1. Quizzes can be locked. Locked quizzes still appear on the front page,
   but are no longer presented as editable quizzes.
   Attempts to circumvent this feature will fail,
   since every write operation on a quiz is checked for being able to write.

1. The program is neither parallel nor distributed.
   In practice, this should not be a problem, 
   since it is unlikely that two moderators compete on input on the same quiz.
   Should this scenario occur, only the later operation for every regular operation,
   and the earlier one in case of the lock operation,
   will win, since both operations will be computed in the sequence of their arrival.

## Requirements

1. To install the program, Haskell is required.
   You can install it via the Haskell Platform on your operating system.
   The bounds on the individual dependencies are rather lax,
   so in theory, the project should be easy to install at any given time.

1. To run the program, you will need some kind of server.
   There are no fixed requirements here, because you can run various servers,
   including localhost, and it all depends on your set-up.

1. To obtain the PDF sheets you shout have `pdflatex` installed and in your environment variable.
   Additionally, there are some non-standard packages used along the way,
   but all of them should be available in a general basic LaTeX package.
   The program will work without `pdflatex` as well,
   but then no sheets and particularly no QR codes will be generated.

## Set-up

1. Clone this repository.

1. Given that Haskell and Cabal are installed,
   call `cabal install`.
   This will install the program in the corresponding Cabal folder.
   If you are using a sandbox, the executable will be located in the sandboxes `bin` folder.

1. Run the program with parameters.

   1. If you are running it locally for testing, the parameters could be
      `-b 127.0.0.1 -p 9000`
      These do specify the host (`-b` part) and the port (`-p`) part.

   1. When running on a proper server, the address is likely `0.0.0.0`,
      since you want it to run as a service.
      The most convenient way is to set it up as a service,
      which is rather simple on Linux based systems.

   1. If you run the program on an `https` connection,
      you need to supply encryption parameters:

      1. `--ssl-address=0.0.0.0`

      1. `--ssl-port=<portNumber>`

      1. `--ssl-cert=<certificate>`

      1. `--no-ssl-chain-cert` or `--ssl-chain-cert` depending on whether or not you
         have a chain certificate.

      1. `--ssl-key=<privatekey>`

   1. The above steps should be enough to run the program.
      In the `https` context you may have to perform some additional steps.
      To have the capability for secure connections,
      the Haskell dependency `snap` needs to be installed with
      the parameter `-fopenssl`.
      To do that run `cabal install snap -fopenssl --force-reinstalls`.
      This may require the additional library `libssl-dev`.
      It is probably already installed,
      the Haskell bindings can be obtained via
      `cabal install HsOpenSSL`.
      Afterwards, you can run `cabal install` again to get the version that
      can handle secure connections.

1. The `config.txt` should contain values for the parameters described below.
   There are sensible defaults, but these have only little flexibility.

   1. `quizzesFolder`: This is the absolute physical path to the folder that contains
      or shall contain all the quizzes.
      In local test setting this is usually `./quizzes`, 
      while in a server setting it is likely something like
      `var/www/my-home-page.edu/stuff/quizzes`.

   1. `serverRelativePath`: This is the relative path from the main server
      (e.g. `www.my-home-page.edu`) to the quizzes folder.
      Technically, it is similar to the `quizzesFolder`, 
      but they do not have to be related.

   1. `database`: This is where the data is kept. All data is maintained in files (for now).
      Note that this folder should not be kept in a public location,
      contrary to the quizzes folder.

## Technology

1. The program is written in Haskell entirely.

1. The pages that are generated are static HTML pages,
   and there are regenerated upon updates.
   The pages use JavaScript internally to call the Chart.js library for drawing the charts.

1. Sensitive REST requests (i.e. posts) are secured by HMAC.
   This means that you cannot arbitrarily manipulate the quizzes,
   because you need a session key, which is only delivered upon login.
   You can, however, resend a previous update to post an earlier state,
   if you manage a man in the middle scenario.
   Still, this might prove difficult, if the connection is encrypted.